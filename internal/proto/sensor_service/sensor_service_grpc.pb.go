// Code generated by protoc-gen-go-grpc. DO NOT EDIT.
// versions:
// - protoc-gen-go-grpc v1.5.1
// - protoc             v3.12.4
// source: sensor_service.proto

package sensor_service

import (
	context "context"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
)

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
// Requires gRPC-Go v1.64.0 or later.
const _ = grpc.SupportPackageIsVersion9

const (
	SensorService_CreateSensorType_FullMethodName = "/sensor_service.SensorService/CreateSensorType"
	SensorService_GetSensorType_FullMethodName    = "/sensor_service.SensorService/GetSensorType"
	SensorService_ListSensorTypes_FullMethodName  = "/sensor_service.SensorService/ListSensorTypes"
	SensorService_UpdateSensorType_FullMethodName = "/sensor_service.SensorService/UpdateSensorType"
	SensorService_DeleteSensorType_FullMethodName = "/sensor_service.SensorService/DeleteSensorType"
	SensorService_CreateSensor_FullMethodName     = "/sensor_service.SensorService/CreateSensor"
	SensorService_GetSensor_FullMethodName        = "/sensor_service.SensorService/GetSensor"
	SensorService_ListSensors_FullMethodName      = "/sensor_service.SensorService/ListSensors"
	SensorService_UpdateSensor_FullMethodName     = "/sensor_service.SensorService/UpdateSensor"
	SensorService_DeleteSensor_FullMethodName     = "/sensor_service.SensorService/DeleteSensor"
	SensorService_SetSensorActive_FullMethodName  = "/sensor_service.SensorService/SetSensorActive"
)

// SensorServiceClient is the client API for SensorService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type SensorServiceClient interface {
	CreateSensorType(ctx context.Context, in *CreateSensorTypeRequest, opts ...grpc.CallOption) (*CreateSensorTypeResponse, error)
	GetSensorType(ctx context.Context, in *GetSensorTypeRequest, opts ...grpc.CallOption) (*GetSensorTypeResponse, error)
	ListSensorTypes(ctx context.Context, in *ListSensorTypesRequest, opts ...grpc.CallOption) (*ListSensorTypesResponse, error)
	UpdateSensorType(ctx context.Context, in *UpdateSensorTypeRequest, opts ...grpc.CallOption) (*UpdateSensorTypeResponse, error)
	DeleteSensorType(ctx context.Context, in *DeleteSensorTypeRequest, opts ...grpc.CallOption) (*DeleteSensorTypeResponse, error)
	CreateSensor(ctx context.Context, in *CreateSensorRequest, opts ...grpc.CallOption) (*CreateSensorResponse, error)
	GetSensor(ctx context.Context, in *GetSensorRequest, opts ...grpc.CallOption) (*GetSensorResponse, error)
	ListSensors(ctx context.Context, in *ListSensorsRequest, opts ...grpc.CallOption) (*ListSensorsResponse, error)
	UpdateSensor(ctx context.Context, in *UpdateSensorRequest, opts ...grpc.CallOption) (*UpdateSensorResponse, error)
	DeleteSensor(ctx context.Context, in *DeleteSensorRequest, opts ...grpc.CallOption) (*DeleteSensorResponse, error)
	SetSensorActive(ctx context.Context, in *SetSensorActiveRequest, opts ...grpc.CallOption) (*SetSensorActiveResponse, error)
}

type sensorServiceClient struct {
	cc grpc.ClientConnInterface
}

func NewSensorServiceClient(cc grpc.ClientConnInterface) SensorServiceClient {
	return &sensorServiceClient{cc}
}

func (c *sensorServiceClient) CreateSensorType(ctx context.Context, in *CreateSensorTypeRequest, opts ...grpc.CallOption) (*CreateSensorTypeResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(CreateSensorTypeResponse)
	err := c.cc.Invoke(ctx, SensorService_CreateSensorType_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *sensorServiceClient) GetSensorType(ctx context.Context, in *GetSensorTypeRequest, opts ...grpc.CallOption) (*GetSensorTypeResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(GetSensorTypeResponse)
	err := c.cc.Invoke(ctx, SensorService_GetSensorType_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *sensorServiceClient) ListSensorTypes(ctx context.Context, in *ListSensorTypesRequest, opts ...grpc.CallOption) (*ListSensorTypesResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ListSensorTypesResponse)
	err := c.cc.Invoke(ctx, SensorService_ListSensorTypes_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *sensorServiceClient) UpdateSensorType(ctx context.Context, in *UpdateSensorTypeRequest, opts ...grpc.CallOption) (*UpdateSensorTypeResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(UpdateSensorTypeResponse)
	err := c.cc.Invoke(ctx, SensorService_UpdateSensorType_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *sensorServiceClient) DeleteSensorType(ctx context.Context, in *DeleteSensorTypeRequest, opts ...grpc.CallOption) (*DeleteSensorTypeResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(DeleteSensorTypeResponse)
	err := c.cc.Invoke(ctx, SensorService_DeleteSensorType_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *sensorServiceClient) CreateSensor(ctx context.Context, in *CreateSensorRequest, opts ...grpc.CallOption) (*CreateSensorResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(CreateSensorResponse)
	err := c.cc.Invoke(ctx, SensorService_CreateSensor_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *sensorServiceClient) GetSensor(ctx context.Context, in *GetSensorRequest, opts ...grpc.CallOption) (*GetSensorResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(GetSensorResponse)
	err := c.cc.Invoke(ctx, SensorService_GetSensor_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *sensorServiceClient) ListSensors(ctx context.Context, in *ListSensorsRequest, opts ...grpc.CallOption) (*ListSensorsResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ListSensorsResponse)
	err := c.cc.Invoke(ctx, SensorService_ListSensors_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *sensorServiceClient) UpdateSensor(ctx context.Context, in *UpdateSensorRequest, opts ...grpc.CallOption) (*UpdateSensorResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(UpdateSensorResponse)
	err := c.cc.Invoke(ctx, SensorService_UpdateSensor_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *sensorServiceClient) DeleteSensor(ctx context.Context, in *DeleteSensorRequest, opts ...grpc.CallOption) (*DeleteSensorResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(DeleteSensorResponse)
	err := c.cc.Invoke(ctx, SensorService_DeleteSensor_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *sensorServiceClient) SetSensorActive(ctx context.Context, in *SetSensorActiveRequest, opts ...grpc.CallOption) (*SetSensorActiveResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(SetSensorActiveResponse)
	err := c.cc.Invoke(ctx, SensorService_SetSensorActive_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// SensorServiceServer is the server API for SensorService service.
// All implementations must embed UnimplementedSensorServiceServer
// for forward compatibility.
type SensorServiceServer interface {
	CreateSensorType(context.Context, *CreateSensorTypeRequest) (*CreateSensorTypeResponse, error)
	GetSensorType(context.Context, *GetSensorTypeRequest) (*GetSensorTypeResponse, error)
	ListSensorTypes(context.Context, *ListSensorTypesRequest) (*ListSensorTypesResponse, error)
	UpdateSensorType(context.Context, *UpdateSensorTypeRequest) (*UpdateSensorTypeResponse, error)
	DeleteSensorType(context.Context, *DeleteSensorTypeRequest) (*DeleteSensorTypeResponse, error)
	CreateSensor(context.Context, *CreateSensorRequest) (*CreateSensorResponse, error)
	GetSensor(context.Context, *GetSensorRequest) (*GetSensorResponse, error)
	ListSensors(context.Context, *ListSensorsRequest) (*ListSensorsResponse, error)
	UpdateSensor(context.Context, *UpdateSensorRequest) (*UpdateSensorResponse, error)
	DeleteSensor(context.Context, *DeleteSensorRequest) (*DeleteSensorResponse, error)
	SetSensorActive(context.Context, *SetSensorActiveRequest) (*SetSensorActiveResponse, error)
	mustEmbedUnimplementedSensorServiceServer()
}

// UnimplementedSensorServiceServer must be embedded to have
// forward compatible implementations.
//
// NOTE: this should be embedded by value instead of pointer to avoid a nil
// pointer dereference when methods are called.
type UnimplementedSensorServiceServer struct{}

func (UnimplementedSensorServiceServer) CreateSensorType(context.Context, *CreateSensorTypeRequest) (*CreateSensorTypeResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CreateSensorType not implemented")
}
func (UnimplementedSensorServiceServer) GetSensorType(context.Context, *GetSensorTypeRequest) (*GetSensorTypeResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetSensorType not implemented")
}
func (UnimplementedSensorServiceServer) ListSensorTypes(context.Context, *ListSensorTypesRequest) (*ListSensorTypesResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ListSensorTypes not implemented")
}
func (UnimplementedSensorServiceServer) UpdateSensorType(context.Context, *UpdateSensorTypeRequest) (*UpdateSensorTypeResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UpdateSensorType not implemented")
}
func (UnimplementedSensorServiceServer) DeleteSensorType(context.Context, *DeleteSensorTypeRequest) (*DeleteSensorTypeResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DeleteSensorType not implemented")
}
func (UnimplementedSensorServiceServer) CreateSensor(context.Context, *CreateSensorRequest) (*CreateSensorResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CreateSensor not implemented")
}
func (UnimplementedSensorServiceServer) GetSensor(context.Context, *GetSensorRequest) (*GetSensorResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetSensor not implemented")
}
func (UnimplementedSensorServiceServer) ListSensors(context.Context, *ListSensorsRequest) (*ListSensorsResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ListSensors not implemented")
}
func (UnimplementedSensorServiceServer) UpdateSensor(context.Context, *UpdateSensorRequest) (*UpdateSensorResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UpdateSensor not implemented")
}
func (UnimplementedSensorServiceServer) DeleteSensor(context.Context, *DeleteSensorRequest) (*DeleteSensorResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DeleteSensor not implemented")
}
func (UnimplementedSensorServiceServer) SetSensorActive(context.Context, *SetSensorActiveRequest) (*SetSensorActiveResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method SetSensorActive not implemented")
}
func (UnimplementedSensorServiceServer) mustEmbedUnimplementedSensorServiceServer() {}
func (UnimplementedSensorServiceServer) testEmbeddedByValue()                       {}

// UnsafeSensorServiceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to SensorServiceServer will
// result in compilation errors.
type UnsafeSensorServiceServer interface {
	mustEmbedUnimplementedSensorServiceServer()
}

func RegisterSensorServiceServer(s grpc.ServiceRegistrar, srv SensorServiceServer) {
	// If the following call pancis, it indicates UnimplementedSensorServiceServer was
	// embedded by pointer and is nil.  This will cause panics if an
	// unimplemented method is ever invoked, so we test this at initialization
	// time to prevent it from happening at runtime later due to I/O.
	if t, ok := srv.(interface{ testEmbeddedByValue() }); ok {
		t.testEmbeddedByValue()
	}
	s.RegisterService(&SensorService_ServiceDesc, srv)
}

func _SensorService_CreateSensorType_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CreateSensorTypeRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(SensorServiceServer).CreateSensorType(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: SensorService_CreateSensorType_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(SensorServiceServer).CreateSensorType(ctx, req.(*CreateSensorTypeRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _SensorService_GetSensorType_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetSensorTypeRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(SensorServiceServer).GetSensorType(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: SensorService_GetSensorType_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(SensorServiceServer).GetSensorType(ctx, req.(*GetSensorTypeRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _SensorService_ListSensorTypes_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ListSensorTypesRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(SensorServiceServer).ListSensorTypes(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: SensorService_ListSensorTypes_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(SensorServiceServer).ListSensorTypes(ctx, req.(*ListSensorTypesRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _SensorService_UpdateSensorType_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UpdateSensorTypeRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(SensorServiceServer).UpdateSensorType(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: SensorService_UpdateSensorType_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(SensorServiceServer).UpdateSensorType(ctx, req.(*UpdateSensorTypeRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _SensorService_DeleteSensorType_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DeleteSensorTypeRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(SensorServiceServer).DeleteSensorType(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: SensorService_DeleteSensorType_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(SensorServiceServer).DeleteSensorType(ctx, req.(*DeleteSensorTypeRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _SensorService_CreateSensor_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CreateSensorRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(SensorServiceServer).CreateSensor(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: SensorService_CreateSensor_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(SensorServiceServer).CreateSensor(ctx, req.(*CreateSensorRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _SensorService_GetSensor_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetSensorRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(SensorServiceServer).GetSensor(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: SensorService_GetSensor_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(SensorServiceServer).GetSensor(ctx, req.(*GetSensorRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _SensorService_ListSensors_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ListSensorsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(SensorServiceServer).ListSensors(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: SensorService_ListSensors_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(SensorServiceServer).ListSensors(ctx, req.(*ListSensorsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _SensorService_UpdateSensor_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UpdateSensorRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(SensorServiceServer).UpdateSensor(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: SensorService_UpdateSensor_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(SensorServiceServer).UpdateSensor(ctx, req.(*UpdateSensorRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _SensorService_DeleteSensor_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DeleteSensorRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(SensorServiceServer).DeleteSensor(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: SensorService_DeleteSensor_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(SensorServiceServer).DeleteSensor(ctx, req.(*DeleteSensorRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _SensorService_SetSensorActive_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SetSensorActiveRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(SensorServiceServer).SetSensorActive(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: SensorService_SetSensorActive_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(SensorServiceServer).SetSensorActive(ctx, req.(*SetSensorActiveRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// SensorService_ServiceDesc is the grpc.ServiceDesc for SensorService service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var SensorService_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "sensor_service.SensorService",
	HandlerType: (*SensorServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "CreateSensorType",
			Handler:    _SensorService_CreateSensorType_Handler,
		},
		{
			MethodName: "GetSensorType",
			Handler:    _SensorService_GetSensorType_Handler,
		},
		{
			MethodName: "ListSensorTypes",
			Handler:    _SensorService_ListSensorTypes_Handler,
		},
		{
			MethodName: "UpdateSensorType",
			Handler:    _SensorService_UpdateSensorType_Handler,
		},
		{
			MethodName: "DeleteSensorType",
			Handler:    _SensorService_DeleteSensorType_Handler,
		},
		{
			MethodName: "CreateSensor",
			Handler:    _SensorService_CreateSensor_Handler,
		},
		{
			MethodName: "GetSensor",
			Handler:    _SensorService_GetSensor_Handler,
		},
		{
			MethodName: "ListSensors",
			Handler:    _SensorService_ListSensors_Handler,
		},
		{
			MethodName: "UpdateSensor",
			Handler:    _SensorService_UpdateSensor_Handler,
		},
		{
			MethodName: "DeleteSensor",
			Handler:    _SensorService_DeleteSensor_Handler,
		},
		{
			MethodName: "SetSensorActive",
			Handler:    _SensorService_SetSensorActive_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "sensor_service.proto",
}
